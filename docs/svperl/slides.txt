Message Based Programming

Dana's Way

There are many like it, but this one is mine

IPC::Transit

Simple?

Simple!!

Version 0.1 has 461 lines of code

A little bit of history

First written some time in the mid 90s

Uploaded to friend's web server

Nobody downloaded it

Probably for the best

Re-implement it every job I've landed at

Only takes a few days each time

Wasn't super clean though

Somebody asked me to give a talk

Damn

Time to write from scratch

Clean and CPAN worthy

(more or less)

ONWARD!

Basic Tenents of Message Based Programming

(Strictly in the context of this talk)

Message Defined:

Arbitrarily complex

'normal'

Starts with hash reference

Normal is defined as scalars, arrays and hashes.

Like this:

{   this => 'thing',
    stuff => ['x', 10, 'y']
}

Works with all serialization methods.

BUT

{   this => 'thing',
    stuff => sub {
        return ['x', $main::foo++, qr/^x$/],
    }
}

Is fun too!

Bless you Data::Dumper

Be aware of the limitations.

Keep it this simple if possible, because it maps well to other languages.

YAD

(Yet Another Diversion)

How I think about things

Decouple first, ask questions later

Not always a good move

But it's where I usually start

Performant designs

Perl is a fairly performant language

Design is the key to performance

Reliable systems

Best way to make a flaky system?

Try to make it 100% reliable!

Reliability by embracing non-reliability

We'll get back to that!

UNIX Philosophy

Doug McIlroy: the inventor of Unix pipes

One of the founders of the Unix tradition

Make each program do one thing well.

To do a new job, build afresh rather than complicate old programs by adding new features.

Expect the output of every program to become the input to another

How about some code?





Think of this method as a dynamic pipeline.

Each Stage is one or more of

A daemon

A coroutine

Coroutine: no blocking!

use strict;use warnings;
use IPC::Transit;
use POE::Something;
make_recurring(recur => 1, work => sub {
    while(my $m = IPC::Transit::receive(qname => 'neat', nonblock => 1)) {
        save_message(%m);
    }
});
make_recurring(recur => 10, work => sub {
    do_fast_thing(@messages);
});
POE::Kernel->run();

Ok, 'coroutines'

Daemon: maybe blocking!

use strict;use warnings;
use IPC::Transit;
while(1) {
    while(my $m = IPC::Transit::receive(qname => 'neat')) {
        $m->{result} = do_slow_thing($m->{thing_to_do});
        IP::Transit::send(message => $m, qname => 'next_step');
    }   
}

State coherence?

The message is the state!*

*Yes, overall.

Sometimes, we keep 'side effects', often for caching.

But there is a real cost

When all state is in the message,

Transparent core scalability

Transparent box scalability

Complex system is VERY easy to reason about

Be an Iconoclast

Why stop there?

sub every_function {
    my %args = @_;
}

Every time.

Every* time.

* most every time.

Core Concept:

Return what you get

Just add your own stuff

Or maybe change some stuff


END PRESENTATION


Free form thoughts

Need some kind of example.

Major on my background: monitoring

Perhaps I need to implement some kind of routing system.

Back to the example:

Make an emitter of random data.  Better yet, something easy and useful like
system uptime.


