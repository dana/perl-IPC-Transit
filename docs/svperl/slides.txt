Message Based Programming

Dana's Way

There are many like it, but this one is mine

IPC::Transit

Simple?

Simple!!

Version 0.1 has 461 lines of code

A little bit of history

First written some time in the mid 90s

Uploaded to friend's web server

Nobody downloaded it

Re-implement it every job I've landed at

Only takes a few days each time

Wasn't super clean though

Somebody asked me to give a talk

Damn

Time to write from scratch

Clean and CPAN worthy

(more or less)

ONWARD!

Basic Tenents of Message Based Programming

(Strictly in the context of this talk)

Message Defined:

Arbitrarily complex

'normal'

Starts with hash reference

Normal is defined as scalars, arrays and hashes.

Like this:

{   this => 'thing',
    stuff => ['x', 10, 'y']
}

Works with all serialization methods.

BUT

{   this => 'thing',
    stuff => sub {
        return ['x', $main::foo++, qr/^x$/],
    },
    nice => sub { return 'thing'; }
}

Is fun too!

Bless you Data::Dumper

Be aware of the limitations.

Keep it this simple if possible, because it maps well to other languages.




Think of this method as a dynamic pipeline.

Each Stage is one or more of

A daemon

A coroutine

Coroutine: no blocking!

use strict;use warnings;
use IPC::Transit;
use POE::Something;
make_recurring(recur => 1, work => sub {
    while(my $m = IPC::Transit::receive(qname => 'neat', nonblock => 1)) {
        save_message(%m);
    }
});
make_recurring(recur => 10, work => sub {
    do_fast_thing(@messages);
});
POE::Kernel->run();

Ok, 'coroutines'

Daemon: maybe blocking!

use strict;use warnings;
use IPC::Transit;
while(1) {
    while(my $m = IPC::Transit::receive(qname => 'neat')) {
        $m->{result} = do_slow_thing($m->{thing_to_do});
        IP::Transit::send(message => $m, qname => 'next_step');
    }   
}

State coherence?

The message is the state!*

*Yes, overall.

Sometimes, we keep 'side effects', often for caching.

But there is a real cost

When all state is in the message,

Transparent core scalability

Transparent box scalability

Complex system is VERY easy to reason about

Be an Iconoclast

Why stop there?

sub every_function {
    my %args = @_;
}

Every time.

Every* time.

* most every time.

Core Concept:

Return what you get

Just add your own stuff

Or maybe change some stuff


END PRESENTATION


Free form thoughts

Need some kind of example.

Major on my background: monitoring

Perhaps I need to implement some kind of routing system.

Back to the example:

Make an emitter of random data.  Better yet, something easy and useful like
system uptime.


